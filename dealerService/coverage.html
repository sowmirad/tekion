
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">bitbucket.org/tekion/tdealer/dealerService/dealerHandler.go (100.0%)</option>
				
				<option value="file1">bitbucket.org/tekion/tdealer/dealerService/dealerModel.go (100.0%)</option>
				
				<option value="file2">bitbucket.org/tekion/tdealer/dealerService/dealerRoutes.go (0.0%)</option>
				
				<option value="file3">bitbucket.org/tekion/tdealer/dealerService/dealerUtil.go (86.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package dealerService

// This file contains handler functions

import (
        //standard libraries
        "errors"
        "net/http"

        //third party libraries
        "github.com/gorilla/context"
        "github.com/gorilla/mux"
        "gopkg.in/mgo.v2"
        "gopkg.in/mgo.v2/bson"

        //tekion specific libraries
        "bitbucket.org/tekion/erratum"
        "bitbucket.org/tekion/tbaas/apiContext"
        "bitbucket.org/tekion/tbaas/tapi"
)

// swagger:operation GET /dealer dealer readDealer
//
// Returns Dealer identified by the dealer id
//
// By default /dealer returns complete dealer object. In case you need only certain fields, you can specify an optional query parameter "fields",
// passing a list of comma separated fields you want in response.
//
// ---
// produces:
// - application/json
// parameters:
// - name: dealerid
//   in: header
//   description: unique identifier of the dealer
//   required: true
//   type: string
// - name: clientid
//   in: header
//   description: client type
//   required: true
//   type: string
// - name: tenantname
//   in: header
//   description: current tenant name
//   required: true
//   type: string
// - name: tekion-api-token
//   in: header
//   description: auth token
//   required: true
//   type: string
// - name: fields
//   in: query
//   description: list of comma separated fields you want in response e.g /dealer?fields=dealerDoingBusinessAsName,vehicleDamage,dealerAddress
//   required: false
//   type: string
// responses:
//   '200':
//     description: dealer object
//     schema:
//         "$ref": "#/definitions/dealer"
//   '204':
//     description: dealer not found in data base
//   '400':
//     description: error querying data base
func readDealer(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := context.Get(r, "apiContext").(apiContext.APIContext)
        //assuming logged in user has access to view all the dealers
        dealerID := ctx.DealerID // should be corrected to Dealer-ID

        fields := fetchFieldsFromRequest(r)
        var dealer dealer

        err := fetchOne(ctx,
                getDealerCollectionName(),
                bson.M{"_id": dealerID},
                fields,
                &amp;dealer,
        )
        if err == mgo.ErrNotFound </span><span class="cov8" title="1">{
                tapi.WriteHTTPResponse(w, http.StatusNoContent, "No document found", nil)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov8" title="1">{
                tapi.WriteHTTPErrorResponse(w, getModuleID(), erratum.ErrorQueryingDB, err)
                return
        }</span>
        // No need to check if some thing was found or not. readOne returns "not found".
        <span class="cov8" title="1">tapi.WriteHTTPResponse(w, http.StatusOK, "Document found", dealer)</span>
}

// swagger:operation GET /fixedoperation/{foid} fixedOperation readFixedOperation
//
// Returns fixed operation identified by fixed operation id passed as part of url
//
// By default /fixedoperation/{foid} returns complete fixed operation object. In case you need only certain fields, you can specify an optional query parameter "fields",
// passing a list of comma separated fields you want in response.
//
// ---
// produces:
// - application/json
// parameters:
// - name: foid
//   in: path
//   description: unique identifier of the fixed operation
//   required: true
//   type: string
// - name: dealerid
//   in: header
//   description: unique identifier of the dealer
//   required: true
//   type: string
// - name: clientid
//   in: header
//   description: client type
//   required: true
//   type: string
// - name: tenantname
//   in: header
//   description: current tenant name
//   required: true
//   type: string
// - name: tekion-api-token
//   in: header
//   description: auth token
//   required: true
//   type: string
// - name: fields
//   in: query
//   description: list of comma separated fields you want in response e.g /fixedoperation/{foid}?fields=serviceAdvisors,floorCapacity,appointmentHour,appointmentCapacity
//   required: false
//   type: string
// responses:
//   '200':
//     description: fixed operation object
//     schema:
//         "$ref": "#/definitions/fixedOperation"
//   '204':
//     description: fixed operation not found in data base
//   '400':
//     description: error querying data base
func readFixedOperation(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        fixedOperationID := vars["foid"]
        if len(fixedOperationID) == 0 </span><span class="cov8" title="1">{
                tapi.WriteHTTPErrorResponse(w, getModuleID(), erratum.ErrorQueryingDB, errors.New("dealer fixed operation id missing in request"))
                return
        }</span>

        <span class="cov8" title="1">var fo FixedOperation
        fields := fetchFieldsFromRequest(r)
        ctx := context.Get(r, "apiContext").(apiContext.APIContext)
        err := fetchOne(ctx,
                getFixedOperationCollectionName(),
                bson.M{"_id": fixedOperationID},
                fields,
                &amp;fo,
        )
        if err == mgo.ErrNotFound </span><span class="cov8" title="1">{
                tapi.WriteHTTPResponse(w, http.StatusNoContent, "No document found", nil)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov8" title="1">{
                tapi.WriteHTTPErrorResponse(w, getModuleID(), erratum.ErrorQueryingDB, err)
                return
        }</span>

        <span class="cov8" title="1">tapi.WriteHTTPResponse(w, http.StatusOK, "Document found", fo)</span>
}

// swagger:operation GET /fixedoperations fixedOperations readFixedOperations
//
// Returns list of fixed operations identified by dealer id passed in header
//
// By default /fixedoperations returns list of complete fixed operation objects. In case you need only certain fields, you can specify an optional query parameter "fields",
// passing a list of comma separated fields you want in response.
//
// ---
// produces:
// - application/json
// parameters:
// - name: dealerid
//   in: header
//   description: unique identifier of the dealer
//   required: true
//   type: string
// - name: clientid
//   in: header
//   description: client type
//   required: true
//   type: string
// - name: tenantname
//   in: header
//   description: current tenant name
//   required: true
//   type: string
// - name: tekion-api-token
//   in: header
//   description: auth token
//   required: true
//   type: string
// - name: fields
//   in: query
//   description: list of comma separated fields you want in response e.g /fixedoperations?field=serviceAdvisors,floorCapacity,appointmentHour,appointmentCapacity
//   required: false
//   type: string
// responses:
//   '200':
//     description: list of fixed operations
//     schema:
//       type: array
//       items:
//         "$ref": "#/definitions/fixedOperation"
//   '204':
//     description: fixed operations not found in data base
//   '400':
//     description: error querying data base
func readFixedOperations(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := context.Get(r, "apiContext").(apiContext.APIContext)
        dealerID := ctx.DealerID // should be corrected to Dealer-ID

        var fixedOperations []FixedOperation
        fields := fetchFieldsFromRequest(r)
        err := fetchFixedOperations(ctx,
                bson.M{"dealerID": dealerID},
                fields,
                &amp;fixedOperations,
        )
        if err != nil </span><span class="cov8" title="1">{
                tapi.WriteHTTPErrorResponse(w, getModuleID(), erratum.ErrorQueryingDB, err)
                return
        }</span>

        <span class="cov8" title="1">if len(fixedOperations) == 0 </span><span class="cov8" title="1">{
                tapi.WriteHTTPResponse(w, http.StatusNoContent, "No document found", nil)
                return
        }</span>
        <span class="cov8" title="1">tapi.WriteHTTPResponse(w, http.StatusOK, "Document found", fixedOperations)</span>
}

// swagger:operation GET /contact/{cid} dealerContact readDealerContact
//
// Returns dealer contact identified by dealer contact id passed as part of url
//
// By default /contact/{cid} returns complete dealer contact object. In case you need only certain fields, you can specify an optional query parameter "fields",
// passing a list of comma separated fields you want in response.
//
// ---
// produces:
// - application/json
// parameters:
// - name: cid
//   in: path
//   description: unique identifier of the dealer contact
//   required: true
//   type: string
// - name: dealerid
//   in: header
//   description: unique identifier of the dealer
//   required: true
//   type: string
// - name: clientid
//   in: header
//   description: client type
//   required: true
//   type: string
// - name: tenantname
//   in: header
//   description: current tenant name
//   required: true
//   type: string
// - name: tekion-api-token
//   in: header
//   description: auth token
//   required: true
//   type: string
// - name: fields
//   in: query
//   description: list of comma separated fields you want in response e.g /contact/{cid}?fields=user,userDisplayName,userDisplayTitle
//   required: false
//   type: string
// responses:
//   '200':
//     description: dealer contact object
//     schema:
//         "$ref": "#/definitions/dealerContact"
//   '204':
//     description: dealer contact not found in data base
//   '400':
//     description: error querying data base
func readDealerContact(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        contactID := vars["cid"]
        if len(contactID) == 0 </span><span class="cov8" title="1">{
                tapi.WriteHTTPErrorResponse(w, getModuleID(), erratum.ErrorQueryingDB, errors.New("dealer contact id missing in request"))
                return
        }</span>

        <span class="cov8" title="1">fields := fetchFieldsFromRequest(r)
        var contact dealerContact
        ctx := context.Get(r, "apiContext").(apiContext.APIContext)
        err := fetchOne(ctx,
                getDealerContactCollectionName(),
                bson.M{"_id": contactID},
                fields,
                &amp;contact,
        )
        if err == mgo.ErrNotFound </span><span class="cov8" title="1">{
                tapi.WriteHTTPResponse(w, http.StatusNoContent, "No document found", nil)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov8" title="1">{
                tapi.WriteHTTPErrorResponse(w, getModuleID(), erratum.ErrorQueryingDB, err)
                return
        }</span>

        <span class="cov8" title="1">tapi.WriteHTTPResponse(w, http.StatusOK, "Document found", contact)</span>
}

// swagger:operation GET /contacts dealerContacts readDealerContacts
//
// Returns list of dealer contacts identified by dealer id passed in header
//
// By default /contacts returns list of complete dealer contacts objects. In case you need only certain fields, you can specify an optional query parameter "fields",
// passing a list of comma separated fields you want in response.
//
// ---
// produces:
// - application/json
// parameters:
// - name: dealerid
//   in: header
//   description: unique identifier of the dealer
//   required: true
//   type: string
// - name: clientid
//   in: header
//   description: client type
//   required: true
//   type: string
// - name: tenantname
//   in: header
//   description: current tenant name
//   required: true
//   type: string
// - name: tekion-api-token
//   in: header
//   description: auth token
//   required: true
//   type: string
// - name: fields
//   in: query
//   description: list of comma separated fields you want in response e.g /contacts?fields=user,userDisplayName,userDisplayTitle
//   required: false
//   type: string
// responses:
//   '200':
//     description: list of dealer contacts
//     schema:
//       type: array
//       items:
//         "$ref": "#/definitions/dealerContact"
//   '204':
//     description: dealer contacts not found in data base
//   '400':
//     description: error querying data base
func readDealerContacts(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := context.Get(r, "apiContext").(apiContext.APIContext)
        dealerID := ctx.DealerID // should be corrected to Dealer-ID

        fields := fetchFieldsFromRequest(r)
        var contacts []dealerContact
        err := fetchDealerContacts(ctx,
                bson.M{"dealerID": dealerID},
                fields,
                &amp;contacts,
        )
        if err != nil </span><span class="cov8" title="1">{
                tapi.WriteHTTPErrorResponse(w, getModuleID(), erratum.ErrorQueryingDB, err)
                return
        }</span>

        <span class="cov8" title="1">if len(contacts) == 0 </span><span class="cov8" title="1">{
                tapi.WriteHTTPResponse(w, http.StatusNoContent, "No document found", nil)
                return
        }</span>
        <span class="cov8" title="1">tapi.WriteHTTPResponse(w, http.StatusOK, "Document found", contacts)</span>
}

// swagger:operation GET /goal/{gid} dealerGoal readDealerGoal
//
// Returns dealer goal identified by dealer goal id passed as part of url
//
// By default /goal/{gid} returns complete dealer goal object. In case you need only certain fields, you can specify an optional query parameter "fields",
// passing a list of comma separated fields you want in response.
//
// ---
// produces:
// - application/json
// parameters:
// - name: gid
//   in: path
//   description: unique identifier of the dealer goal
//   required: true
//   type: string
// - name: dealerid
//   in: header
//   description: unique identifier of the dealer
//   required: true
//   type: string
// - name: clientid
//   in: header
//   description: client type
//   required: true
//   type: string
// - name: tenantname
//   in: header
//   description: current tenant name
//   required: true
//   type: string
// - name: tekion-api-token
//   in: header
//   description: auth token
//   required: true
//   type: string
// - name: fields
//   in: query
//   description: list of comma separated fields you want in response e.g /goal/{id}?fields=hoursPerRepairOrderAdvisorGoal,totalHoursAdvisorGoal,averageLaborRateAdvisorGoal
//   required: false
//   type: string
// responses:
//   '200':
//     description: dealer goal object
//     schema:
//         "$ref": "#/definitions/dealerGoal"
//   '204':
//     description: dealer goal not found in data base
//   '400':
//     description: error querying data base
func readDealerGoal(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        vars := mux.Vars(r)
        goalID := vars["gid"]
        if len(goalID) == 0 </span><span class="cov8" title="1">{
                tapi.WriteHTTPErrorResponse(w, getModuleID(), erratum.ErrorQueryingDB, errors.New("dealer goal id missing in request"))
                return
        }</span>

        <span class="cov8" title="1">fields := fetchFieldsFromRequest(r)
        var goal dealerGoal
        ctx := context.Get(r, "apiContext").(apiContext.APIContext)
        err := fetchOne(ctx,
                getDealerGoalCollectionName(),
                bson.M{"_id": goalID},
                fields,
                &amp;goal,
        )
        if err == mgo.ErrNotFound </span><span class="cov8" title="1">{
                tapi.WriteHTTPResponse(w, http.StatusNoContent, "No document found", nil)
                return
        }</span><span class="cov8" title="1"> else if err != nil </span><span class="cov8" title="1">{
                tapi.WriteHTTPErrorResponse(w, getModuleID(), erratum.ErrorQueryingDB, err)
                return
        }</span>

        <span class="cov8" title="1">tapi.WriteHTTPResponse(w, http.StatusOK, "Document found", goal)</span>
}

// swagger:operation GET /goals dealerGoals readDealerGoals
//
// Returns list of dealer goals identified by dealer id passed in header
//
// By default /goals returns list of complete dealer goals objects. In case you need only certain fields, you can specify an optional query parameter "fields",
// passing a list of comma separated fields you want in response.
//
// ---
// produces:
// - application/json
// parameters:
// - name: dealerid
//   in: header
//   description: unique identifier of the dealer
//   required: true
//   type: string
// - name: clientid
//   in: header
//   description: client type
//   required: true
//   type: string
// - name: tenantname
//   in: header
//   description: current tenant name
//   required: true
//   type: string
// - name: tekion-api-token
//   in: header
//   description: auth token
//   required: true
//   type: string
// - name: fields
//   in: query
//   description: list of comma separated fields you want in response e.g /goals?fields=hoursPerRepairOrderAdvisorGoal,totalHoursAdvisorGoal,averageLaborRateAdvisorGoal
//   required: false
//   type: string
// responses:
//   '200':
//     description: list of dealer goals
//     schema:
//       type: array
//       items:
//         "$ref": "#/definitions/dealerGoal"
//   '204':
//     description: dealer goals not found in data base
//   '400':
//     description: error querying data base
func readDealerGoals(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := context.Get(r, "apiContext").(apiContext.APIContext)
        dealerID := ctx.DealerID // should be corrected to Dealer-ID

        fields := fetchFieldsFromRequest(r)
        var goals []dealerGoal
        err := fetchDealerGoals(ctx,
                bson.M{"dealerID": dealerID},
                fields,
                &amp;goals,
        )

        if err != nil </span><span class="cov8" title="1">{
                tapi.WriteHTTPErrorResponse(w, getModuleID(), erratum.ErrorQueryingDB, err)
                return
        }</span>

        <span class="cov8" title="1">if len(goals) == 0 </span><span class="cov8" title="1">{
                tapi.WriteHTTPResponse(w, http.StatusNoContent, "No document found", nil)
                return
        }</span>
        <span class="cov8" title="1">tapi.WriteHTTPResponse(w, http.StatusOK, "Document found", goals)</span>
}

// swagger:operation GET /groups dealerGroups readDealerGroups
//
// Returns list of dealer groups identified by dealer id passed in header
//
// By default /groups returns list of complete dealer groups objects. In case you need only certain fields, you can specify an optional query parameter "fields",
// passing a list of comma separated fields you want in response.
//
// ---
// produces:
// - application/json
// parameters:
// - name: dealerid
//   in: header
//   description: unique identifier of the dealer
//   required: true
//   type: string
// - name: clientid
//   in: header
//   description: client type
//   required: true
//   type: string
// - name: tenantname
//   in: header
//   description: current tenant name
//   required: true
//   type: string
// - name: tekion-api-token
//   in: header
//   description: auth token
//   required: true
//   type: string
// - name: fields
//   in: query
//   description: list of comma separated fields you want in response e.g /groups?fields=dealerGroupName,dealerGroupName,dealers
//   required: false
//   type: string
// responses:
//   '200':
//     description: list of dealer groups
//     schema:
//       type: array
//       items:
//         "$ref": "#/definitions/dealerGroup"
//   '204':
//     description: dealer groups not found in data base
//   '400':
//     description: error querying data base
func readDealerGroups(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := context.Get(r, "apiContext").(apiContext.APIContext)
        dealerID := ctx.DealerID // should be corrected to Dealer-ID

        fields := fetchFieldsFromRequest(r)
        var groups []dealerGroup
        err := fetchDealerGroups(ctx,
                bson.M{"dealers": dealerID},
                fields,
                &amp;groups,
        )

        if err != nil </span><span class="cov8" title="1">{
                tapi.WriteHTTPErrorResponse(w, getModuleID(), erratum.ErrorQueryingDB, err)
                return
        }</span>

        <span class="cov8" title="1">if len(groups) == 0 </span><span class="cov8" title="1">{
                tapi.WriteHTTPResponse(w, http.StatusNoContent, "No document found", nil)
                return
        }</span>
        <span class="cov8" title="1">tapi.WriteHTTPResponse(w, http.StatusOK, "Document found", groups)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package dealerService

// This file contains all the models related to dealer

// TODO add swagger support

import (
        "time"
)

// Collection names used by dealer service
const (
        dealerCollectionName         = "DealerMaster"
        fixedOperationCollectionName = "FixedOperation"
        dealerContactCollectionName  = "DealerContact"
        dealerGoalCollectionName     = "DealerGoal"
        dealerGroupCollectionName    = "DealerGroup"
)

// getDealerCollectionName returns dealer collection name
func getDealerCollectionName() string <span class="cov8" title="1">{
        return dealerCollectionName
}</span>

// getFixedOperationCollectionName returns dealer fixed operation collection name
func getFixedOperationCollectionName() string <span class="cov8" title="1">{
        return fixedOperationCollectionName
}</span>

// getDealerContactCollectionName returns the dealer contact collection name
func getDealerContactCollectionName() string <span class="cov8" title="1">{
        return dealerContactCollectionName
}</span>

// getDealerGoalCollectionName returns the dealer goal collection name
func getDealerGoalCollectionName() string <span class="cov8" title="1">{
        return dealerGoalCollectionName
}</span>

// dealerGroupCollectionName returns the dealer group collection name
func getDealerGroupCollectionName() string <span class="cov8" title="1">{
        return dealerGroupCollectionName
}</span>

// getModuleID returns the module id
func getModuleID() string <span class="cov8" title="1">{
        return "tdealer"
}</span>

/*
Moved EPA and BAR numbers to fixed operations
Unclear at this point, we will handle CustomerCommunicationSource, DealerCommunication, OutGoingEmail, IncomingEmail and Email later
CustomerCommunicationSource string                                        `bson:"CustomerCommunicationSource" json:"CustomerCommunicationSource"` // Customer Communication Source ? Any example
DealerCommunication                 []dealerCommunication         `bson:"dealerCommunication" json:"dealerCommunication"`
OutGoingEmail                                 string                                         `bson:"outGoingEmail" json:"outGoingEmail"`
IncomingEmail                                 string                                         `bson:"incomingEmail" json:"incomingEmail"`
Email                                 string                                  `bson:"email" json:"email"`
Not sure about dealerShipCode mapping with dealerGroups
Created a new collection for dealer group
*/

// dealer struct contains dealer details
// swagger:model dealer
type dealer struct {
        ID                       string                    `bson:"_id" json:"dealerID,omitempty"`                                        //Dealer Identification  - Keep it Unique across the tenant
        Name                     string                    `bson:"dealerName" json:"dealerName,omitempty"`                               //Dealer Name
        MakeCode                 []string                  `bson:"makeCode" json:"makeCode,omitempty"`                                   //Make Code - Car manufacturer code // made slice of string on Prameet's recommendation
        DoingBusinessAsName      string                    `bson:"dealerDoingBusinessAsName" json:"dealerDoingBusinessAsName,omitempty"` //Dealer Doing Business As Name. This may or may not be government registered Name for the business
        StateIssuedNumber        string                    `bson:"stateIssuedNumber" json:"stateIssuedNumber,omitempty"`                 //State Government registered or issued Number
        ManufacturerIssuedNumber string                    `bson:"manufacturerIssuedNumber" json:"manufacturerIssuedNumber,omitempty"`   // Manufacturer (OEM) registered-issued Number.
        Website                  string                    `bson:"website" json:"website,omitempty"`                                     //Dealer website URL
        Timezone                 string                    `bson:"timezone" json:"timezone,omitempty"`                                   // Dealer's timezone like PST ( Pacific standard Time)
        Currency                 string                    `bson:"currency" json:"currency,omitempty"`                                   // Dealer Currency --  DEFAULT 'USD'
        TenantID                 string                    `bson:"tenantID" json:"tenantID,omitempty"`                                   // Tenant Identification Number
        Phone                    string                    `bson:"phone" json:"phone,omitempty"`                                         // Dealership phone Contact
        Logos                    []image                   `bson:"dealerLogos" json:"dealerLogos,omitempty"`                             // Store Logos in slice of image // changed name from dealerLogoURL to dealerLogos
        VehicleDamage            []vehicleDamage           `bson:"vehicleDamage" json:"vehicleDamage,omitempty"`                         //
        DealershipCode           string                    `bson:"dealershipCode" json:"dealershipCode,omitempty"`                       // Dealership Code.  A dealership can have one or more dealers in it.( Requested to change to dealerCode. But this is not one to one as dealerID, thats the reason we put it as dealershipCode, This is kind of dealerGroupCode)
        Group                    []string                  `bson:"dealerGroup" json:"dealerGroup,omitempty"`                             //
        Address                  []dealerAddress           `bson:"dealerAddress" json:"dealerAddress,omitempty"`                         //
        DocumentTemplates        []dealerDocumentTemplate  `bson:"dealerDocumentTemplates" json:"dealerDocumentTemplates,omitempty"`     //
        OperationSchedule        []dealerOperationSchedule `bson:"dealerOperationSchedule" json:"dealerOperationSchedule,omitempty"`     //
        Contact                  []string                  `bson:"dealerContact" json:"dealerContact,omitempty"`                         //
        IsActive                 bool                      `bson:"isActive" json:"isActive,omitempty"`                                   // Is Active T or F (TRUE or FALSE) -- DEFAULT 'T'
        LastUpdatedByUser        string                    `bson:"lastUpdatedByUser" json:"lastUpdatedByUser,omitempty"`                 // Last Updated By User
        LastUpdatedByDisplayName string                    `bson:"lastUpdatedByDisplayName" json:"lastUpdatedByDisplayName,omitempty"`   // This is to Display the Name in the application
        // format: date-time
        LastUpdatedDateTime time.Time `bson:"lastUpdatedDateTime" json:"lastUpdatedDateTime,omitempty"` // When was this last updated Date and Time -- DEFAULT CURRENT_TIMESTAMP
        DocumentVersion     float32   `bson:"documentVersion" json:"documentVersion,omitempty"`         // Document version to keep track of the changes -- DEFAULT 1.0
}

// dealerContact
// swagger:model dealerContact
type dealerContact struct {
        ID                       string `bson:"_id" json:"dealerContactID,omitempty"`                               //
        DealerID                 string `bson:"dealerID" json:"dealerID,omitempty"`                                 // Dealer Identification Number
        DealerOperationType      string `bson:"dealerOperationType" json:"dealerOperationType,omitempty"`           // Dealer Operation Type - // Fixed Operations-Services, Sales, Parts, Management etc
        User                     string `bson:"user" json:"user,omitempty"`                                         // User Id or Login name ( ex: sig@tekion.com )
        UserDisplayName          string `bson:"userDisplayName" json:"userDisplayName,omitempty"`                   // Dealer Contact/User Display Name like "Scott Hertler "
        UserDisplayTitle         string `bson:"userDisplayTitle" json:"userDisplayTitle,omitempty"`                 // Dealer Contact or User Title like "General Manager" or "Parts Clerk"
        IsActive                 bool   `bson:"isActive" json:"isActive,omitempty"`                                 // Is Active T or F (TRUE or FALSE) -- DEFAULT 'T'
        LastUpdatedByUser        string `bson:"lastUpdatedByUser" json:"lastUpdatedByUser,omitempty"`               // Last Updated By User
        LastUpdatedByDisplayName string `bson:"lastUpdatedByDisplayName" json:"lastUpdatedByDisplayName,omitempty"` // This is to Display the Name in the application
        // format: date-time
        LastUpdatedDateTime time.Time `bson:"lastUpdatedDateTime" json:"lastUpdatedDateTime,omitempty"` // When was this last updated Date and Time -- DEFAULT CURRENT_TIMESTAMP
        DocumentVersion     float32   `bson:"documentVersion" json:"documentVersion,omitempty"`         // Document version to keep track of the changes -- DEFAULT 1.0
}

// Embedded objects in dealer -- start

// image struct contains details of the image stored in S3 bucket, stored as slice of embedded objects in dealer struct
// swagger:model image
type image struct {
        Width   string `bson:"width" json:"width,omitempty"`     //required
        Height  string `bson:"height" json:"height,omitempty"`   //required
        Title   string `bson:"title" json:"title,omitempty"`     //
        ImageID string `bson:"imageID" json:"imageID,omitempty"` //UUID =&gt; name of the image stored in S3 bucket
}

// dealerAddress struct contains details of the dealer address, stored as embedded objects in dealer struct
// swagger:model dealerAddress
type dealerAddress struct {
        ID             string `bson:"dealerAddressID" json:"dealerAddressID,omitempty"` // Dealer Identification
        AddressType    string `bson:"addressType" json:"addressType,omitempty"`         // Dealer Address Type like Service, Sales, Parts etc
        StreetAddress1 string `bson:"streetAddress1" json:"streetAddress1,omitempty"`   // Dealer Address1
        StreetAddress2 string `bson:"streetAddress2" json:"streetAddress2,omitempty"`   // Dealer Street Address2
        City           string `bson:"city" json:"city,omitempty"`                       // Dealer location City
        State          string `bson:"state" json:"state,omitempty"`                     // Dealer Location State
        ZipCode        string `bson:"zipCode" json:"zipCode,omitempty"`                 // Dealer Zip Code - Postal Code
        Country        string `bson:"country" json:"country,omitempty"`                 // Dealer Country
        County         string `bson:"county" json:"county,omitempty"`                   // Dealer Location County
        IsActive       bool   `bson:"isActive" json:"isActive,omitempty"`               // Is Active T or F (TRUE or FALSE) -- DEFAULT 'T'
}

// TODO : still unclear where and how to store it

// dealerCommunication struct contains details of the dealer communication
// swagger:model dealerCommunication
type dealerCommunication struct {
        ID                          string `bson:"dealerCommunicationID" json:"dealerCommunicationID,omitempty"`             //
        DealerID                    string `bson:"dealerID" json:"dealerID,omitempty"`                                       // Dealer Identification  - Keep it Unique across the tenant
        CustomerCommunicationSource string `bson:"customerCommunicationSource" json:"customerCommunicationSource,omitempty"` // Customer Communication Source ? Any example
        OutGoingEmail               string `bson:"outGoingEmail" json:"outGoingEmail,omitempty"`                             // Customer communication Out going email ?
        IncomingEmail               string `bson:"incomingEmail" json:"incomingEmail,omitempty"`                             // Customer communication incoming email ?
        Phone                       string `bson:"phone" json:"phone,omitempty"`                                             // Dealership phone Contact
        IsActive                    bool   `bson:"isActive" json:"isActive,omitempty"`                                       // Is Active T or F (TRUE or FALSE) -- DEFAULT 'T'
}

// dealerDocumentTemplate struct contains details of the templates specific to the dealer, stored as slice of embedded objects in dealer struct
// swagger:model dealerDocumentTemplate
type dealerDocumentTemplate struct {
        ID              string `bson:"dealerDocumentTemplateID" json:"dealerDocumentTemplateID,omitempty"` //
        TemplateName    string `bson:"templateName" json:"templateName,omitempty"`                         // Template Name ( What is the use of this templates)
        TemplateType    string `bson:"templateType" json:"templateType,omitempty"`                         // Template Type like Appointment, Estimate, Repair Order, Invoice etc
        TemplateImageID string `bson:"templateImageID" json:"templateImageID,omitempty"`                   // Changed from Template URL to TemplateImageID stored in S3 bucket
        IsActive        bool   `bson:"isActive" json:"isActive,omitempty"`                                 // Is Active T or F (TRUE or FALSE) -- DEFAULT 'T'
}

// dealerOperationSchedule struct contains details of the dealer operation schedule, stored as slice of embedded objects in dealer struct
// swagger:model dealerOperationSchedule
type dealerOperationSchedule struct {
        ID                  string `bson:"dealerOperationScheduleID" json:"dealerOperationScheduleID,omitempty"` //
        DealerOperationType string `bson:"dealerOperationType" json:"dealerOperationType,omitempty"`             //Dealer Operation Type - // Fixed Operations-Services, Sales, Parts, Management etc
        SundayOpenHour      string `bson:"sundayOpenHour" json:"sundayOpenHour,omitempty"`                       // Business Open Hour or Office start time today : 7:00 AM
        SundayCloseHour     string `bson:"sundayCloseHour" json:"sundayCloseHour,omitempty"`                     // Business Close Hour or Office end time today: 5:00 PM
        MondayOpenHour      string `bson:"mondayOpenHour" json:"mondayOpenHour,omitempty"`                       // Business Open Hour or Office start time today : 7:00 AM
        MondayCloseHour     string `bson:"mondayCloseHour" json:"mondayCloseHour,omitempty"`                     // Business Close Hour or Office end time today: 5:00 PM
        TuesdayOpenHour     string `bson:"tuesdayOpenHour" json:"tuesdayOpenHour,omitempty"`                     // Business Open Hour or Office start time today : 7:00 AM
        TuesdayCloseHour    string `bson:"tuesdayCloseHour" json:"tuesdayCloseHour,omitempty"`                   // Business Close Hour or Office end time today: 5:00 PM
        WednesdayOpenHour   string `bson:"wednesdayOpenHour" json:"wednesdayOpenHour,omitempty"`                 // Business Open Hour or Office start time today : 7:00 AM
        WednesdayCloseHour  string `bson:"wednesdayCloseHour" json:"wednesdayCloseHour,omitempty"`               // Business Close Hour or Office end time today: 5:00 PM
        ThursdayOpenHour    string `bson:"thursdayOpenHour" json:"thursdayOpenHour,omitempty"`                   // Business Open Hour or Office start time today : 7:00 AM
        ThursdayCloseHour   string `bson:"thursdayCloseHour" json:"thursdayCloseHour,omitempty"`                 // Business Close Hour or Office end time today: 5:00 PM
        FridayOpenHour      string `bson:"fridayOpenHour" json:"fridayOpenHour,omitempty"`                       // Business Open Hour or Office start time today : 7:00 AM
        FridayCloseHour     string `bson:"fridayCloseHour" json:"fridayCloseHour,omitempty"`                     // Business Close Hour or Office end time today: 5:00 PM
        SaturdayOpenHour    string `bson:"saturdayOpenHour" json:"saturdayOpenHour,omitempty"`                   // Business Open Hour or Office start time today : 7:00 AM
        SaturdayCloseHour   string `bson:"saturdayCloseHour" json:"saturdayCloseHour,omitempty"`                 // Business Close Hour or Office end time today: 5:00 PM
}

// vehicleDamage struct contains details of the dealer vehicle damage types, stored as slice of embedded objects in dealer struct
// swagger:model vehicleDamage
type vehicleDamage struct {
        ID          string `bson:"vehicleDamageID" json:"vehicleDamageID"` //
        ImageURL    string `bson:"imageURL" json:"imageURL"`               //
        DamageType  string `bson:"damageType" json:"damageType"`           //
        Description string `bson:"description" json:"description"`         //
        Priority    int    `bson:"priority" json:"priority"`               // Decided the sequence in which damage types will be displayed on UI
}

// Embedded objects in Dealer -- end

// When get appointment hrs check it its a holiday or not
// date is stored in utc
// date should be converted to dealer time zone

// fixedOperation struct contains dealer fixed operation details
// swagger:model fixedOperation
type FixedOperation struct {
        ID                       string                `bson:"_id" json:"fixedOperationID,omitempty"`                              //
        DealerID                 string                `bson:"dealerID" json:"dealerID,omitempty"`                                 // Dealer Identification
        EPANumber                string                `bson:"EPANumber" json:"EPANumber,omitempty"`                               // Name correction -- capitalize abbreviations
        BARNumber                string                `bson:"BARNumber" json:"BARNumber,omitempty"`                               // Name correction -- capitalize abbreviations
        ManufacturerLogos        []image               `bson:"manufacturerLogos" json:"manufacturerLogos,omitempty"`               // Store Logos in slice of image // changed name from manufacturerLogo to manufacturerLogos
        Holidays                 []holiday             `bson:"holidays" json:"holidays,omitempty"`                                 //
        ServiceAdvisors          []users               `bson:"serviceAdvisors" json:"serviceAdvisors,omitempty"`                   // make sure during insertion that only service advisors are stored in here
        FloorCapacity            []floorCapacity       `bson:"floorCapacity" json:"floorCapacity,omitempty"`                       //
        AppointmentHour          appointmentHour       `bson:"appointmentHour" json:"appointmentHour,omitempty"`                   //
        AppointmentCapacity      []appointmentCapacity `bson:"appointmentCapacity" json:"appointmentCapacity,omitempty"`           //
        Amenities                []amenities           `bson:"amenities" json:"amenities,omitempty"`                               //
        IsActive                 bool                  `bson:"isActive" json:"isActive,omitempty"`                                 // Is Active T or F (TRUE or FALSE) -- DEFAULT 'T'
        LastUpdatedByUser        string                `bson:"lastUpdatedByUser" json:"lastUpdatedByUser,omitempty"`               // Last Updated By User
        LastUpdatedByDisplayName string                `bson:"lastUpdatedByDisplayName" json:"lastUpdatedByDisplayName,omitempty"` // This is to Display the Name in the application
        // format: date-time
        LastUpdatedDateTime time.Time `bson:"lastUpdatedDateTime" json:"lastUpdatedDateTime,omitempty"` // When was this last updated Date and Time -- DEFAULT CURRENT_TIMESTAMP
        DocumentVersion     float32   `bson:"documentVersion" json:"documentVersion,omitempty"`         // Document version to keep track of the changes -- DEFAULT 1.0
        //Moved to DealerGoal hoursPerRepairOrderAdvisorGoal, totalHoursAdvisorGoal, averageLaborRateAdvisorGoal
        //Moved AppointmentsPerSlot, AppointmentSlotDuration to appointmentCapacity
}

// Embedded structures in fixed operations-- start

// TODO : need inputs from Venkat on start end and carryover fields

// holiday struct contains details of holidays, stored as slice of embedded objects in fixed operation struct
// swagger:model holiday
type holiday struct {
        Date               string `bson:"date" json:"date,omitempty"`                             // ask for date format used in Tekion
        StartOperationHour string `bson:"startOperationHour" json:"startOperationHour,omitempty"` // not sure about its use ??
        EndOperationHour   string `bson:"endOperationHour" json:"endOperationHour,omitempty"`     // not sure about its use ??
        CarryOver          bool   `bson:"carryOver" json:"carryOver,omitempty"`                   // not sure about its use ??
}

// users struct contains details of the users detail specific to the dealer, stored as slice of embedded objects in fixed operation struct
// Using generic user type instead of serviceAdvisor type
// swagger:model users
type users struct {
        DealerID string `bson:"dealerID" json:"dealerID,omitempty"` // maps to Dealer.ID
        UserID   string `bson:"userID" json:"userID,omitempty"`     // maps to User.ID
        JobTitle string `bson:"jobTitle" json:"jobTitle,omitempty"` // maps to User.jobTitle
}

// floorCapacity struct contains details of dealer floor capacities, , stored as slice of embedded objects in fixed operation struct
// swagger:model floorCapacity
type floorCapacity struct {
        SkillCode     string `bson:"skillCode" json:"skillCode,omitempty"`         // maps to SkillMaster.ID
        SkillName     string `bson:"skillName" json:"skillName,omitempty"`         // maps to skillMaster.Name added // Name is rarely going to change, keeping a copy here to avoid extra call to skillMaster
        SundayHours   string `bson:"sundayHours" json:"sundayHours,omitempty"`     //
        MondayHour    string `bson:"mondayHour" json:"mondayHour,omitempty"`       //
        TuesdayHour   string `bson:"tuesdayHour" json:"tuesdayHour,omitempty"`     //
        WednesdayHour string `bson:"wednesdayHour" json:"wednesdayHour,omitempty"` //
        ThursdayHour  string `bson:"thursdayHour" json:"thursdayHour,omitempty"`   //
        FridayHour    string `bson:"fridayHour" json:"fridayHour,omitempty"`       //
        SaturdayHour  string `bson:"saturdayHour" json:"saturdayHour,omitempty"`   //
        Total         string `bson:"total" json:"total"`                           // added ask // Can also be calculated by front end
}

// appointmentHour struct contains details appointment hours, stored as embedded object in fixed operation struct
// swagger:model appointmentHour
type appointmentHour struct {
        SundayOpenHour     string `bson:"sundayOpenHour" json:"sundayOpenHour,omitempty"`         //
        SundayCloseHour    string `bson:"sundayCloseHour" json:"sundayCloseHour,omitempty"`       //
        MondayOpenHour     string `bson:"mondayOpenHour" json:"mondayOpenHour,omitempty"`         //
        MondayCloseHour    string `bson:"mondayCloseHour" json:"mondayCloseHour,omitempty"`       //
        TuesdayOpenHour    string `bson:"tuesdayOpenHour" json:"tuesdayOpenHour,omitempty"`       //
        TuesdayCloseHour   string `bson:"tuesdayCloseHour" json:"tuesdayCloseHour,omitempty"`     //
        WednesdayOpenHour  string `bson:"wednesdayOpenHour" json:"wednesdayOpenHour,omitempty"`   //
        WednesdayCloseHour string `bson:"wednesdayCloseHour" json:"wednesdayCloseHour,omitempty"` //
        ThursdayOpenHour   string `bson:"thursdayOpenHour" json:"thursdayOpenHour,omitempty"`     //
        ThursdayCloseHour  string `bson:"thursdayCloseHour" json:"thursdayCloseHour,omitempty"`   //
        FridayOpenHour     string `bson:"fridayOpenHour" json:"fridayOpenHour,omitempty"`         //
        FridayCloseHour    string `bson:"fridayCloseHour" json:"fridayCloseHour,omitempty"`       //
        SaturdayOpenHour   string `bson:"saturdayOpenHour" json:"saturdayOpenHour,omitempty"`     //
        SaturdayCloseHour  string `bson:"saturdayCloseHour" json:"saturdayCloseHour,omitempty"`   //
}

// appointmentCapacity struct contains details of the number of hours present for each skill, stored as slice of embedded objects in fixed operation struct
// swagger:model appointmentCapacity
type appointmentCapacity struct {
        SkillCode               string `bson:"skillCode" json:"skillCode,omitempty"`                             // maps to SkillMaster._id
        SkillName               string `bson:"skillName" json:"skillName,omitempty"`                             // maps to skillMaster.Name added // Name is rarely going to change, keeping a copy here to avoid extra call
        NumberOfServiceAdvisors int16  `bson:"numberOfServiceAdvisors" json:"numberOfServiceAdvisors,omitempty"` // data type changed to int16 on Prameet's input
        AppointmentsPerSlot     int16  `bson:"appointmentsPerSlot" json:"appointmentsPerSlot,omitempty"`         // data type changed to int16 on Prameet's input
        AppointmentSlotDuration int16  `bson:"appointmentSlotDuration" json:"appointmentSlotDuration,omitempty"` // data type changed to int16 on Prameet's input
        Sunday                  string `bson:"sunday" json:"sunday,omitempty"`                                   //
        Monday                  string `bson:"monday" json:"monday,omitempty"`                                   //
        Tuesday                 string `bson:"tuesday" json:"tuesday,omitempty"`                                 //
        Wednesday               string `bson:"wednesday" json:"wednesday,omitempty"`                             //
        Thursday                string `bson:"thursday" json:"thursday,omitempty"`                               //
        Friday                  string `bson:"friday" json:"friday,omitempty"`                                   //
        Saturday                string `bson:"saturday" json:"saturday,omitempty"`                               //
}

// amenities struct contains list of dealer amenities, stored as slice of embedded objects in fixed operation struct
// swagger:model amenities
type amenities struct {
        ID   string `bson:"amenityID" json:"amenityID,omitempty"` //maps to AmenitiesMaster._id
        Name string `bson:"name" json:"name,omitempty"`           // maps to AmenitiesMaster.name
}

// Embedded structures in fixed operations-- end

// dealerGoal
// swagger:model dealerGoal
type dealerGoal struct {
        // dealerGoalID
        ID string `bson:"_id" json:"dealerGoalID,omitempty"`
        // dealerID
        DealerID string `bson:"dealerID" json:"dealerID,omitempty"`
        // hoursPerRepairOrderAdvisorGoal
        HoursPerRepairOrderAdvisorGoal string `bson:"hoursPerRepairOrderAdvisorGoal" json:"hoursPerRepairOrderAdvisorGoal,omitempty"`
        // totalHoursAdvisorGoal
        TotalHoursAdvisorGoal string `bson:"totalHoursAdvisorGoal" json:"totalHoursAdvisorGoal,omitempty"`
        // averageLaborRateAdvisorGoal
        AverageLaborRateAdvisorGoal string `bson:"averageLaborRateAdvisorGoal" json:"averageLaborRateAdvisorGoal,omitempty"`
        // Last Updated By User
        LastUpdatedByUser string `bson:"lastUpdatedByUser" json:"lastUpdatedByUser,omitempty"`
        // This is to Display the Name in the application
        LastUpdatedByDisplayName string `bson:"lastUpdatedByDisplayName" json:"lastUpdatedByDisplayName,omitempty"`
        // When was this last updated Date and Time -- DEFAULT CURRENT_TIMESTAMP
        // format: date-time
        LastUpdatedDateTime time.Time `bson:"lastUpdatedDateTime" json:"lastUpdatedDateTime,omitempty"`
        // Document version to keep track of the changes -- DEFAULT 1.0
        DocumentVersion float32 `bson:"documentVersion" json:"documentVersion,omitempty"`
}

// dealerGroup
// swagger:model dealerGroup
type dealerGroup struct {
        //dealerGroupID
        ID string `bson:"_id" json:"dealerGroupID,omitempty"`
        // dealerGroupName
        Name string `bson:"dealerGroupName" json:"dealerGroupName,omitempty"`
        // dealers
        Dealers []string `bson:"dealers" json:"dealers,omitempty"`
        // description
        Desc string `bson:"description" json:"description,omitempty"`
        // Last Updated By User
        LastUpdatedByUser string `bson:"lastUpdatedByUser" json:"lastUpdatedByUser,omitempty"`
        // This is to Display the Name in the application
        LastUpdatedByDisplayName string `bson:"lastUpdatedByDisplayName" json:"lastUpdatedByDisplayName,omitempty"`
        // When was this last updated Date and Time -- DEFAULT CURRENT_TIMESTAMP
        // format: date-time
        LastUpdatedDateTime time.Time `bson:"lastUpdatedDateTime" json:"lastUpdatedDateTime,omitempty"`
        // Document version to keep track of the changes -- DEFAULT 1.0
        DocumentVersion float32 `bson:"documentVersion" json:"documentVersion,omitempty"`
}

//Missing collections in mongo -- start
/*
type SkillMaster struct {
        LastUpdatedByUser        string    `bson:"lastUpdatedByUser" json:"lastUpdatedByUser"`               // Last Updated By User
        LastUpdatedByDisplayName string    `bson:"lastUpdatedByDisplayName" json:"lastUpdatedByDisplayName"` // This is to Display the Name in the application
        LastUpdatedDateTime      time.Time `bson:"lastUpdatedDateTime" json:"lastUpdatedDateTime"`           // When was this last updated Date and Time -- DEFAULT CURRENT_TIMESTAMP
        DocumentVersion          float32   `bson:"documentVersion" json:"documentVersion"`                   // Document version to keep track of the changes -- DEFAULT 1.0
}

type AmenitiesMaster struct {
        LastUpdatedByUser        string    `bson:"lastUpdatedByUser" json:"lastUpdatedByUser"`               // Last Updated By User
        LastUpdatedByDisplayName string    `bson:"lastUpdatedByDisplayName" json:"lastUpdatedByDisplayName"` // This is to Display the Name in the application
        LastUpdatedDateTime      time.Time `bson:"lastUpdatedDateTime" json:"lastUpdatedDateTime"`           // When was this last updated Date and Time -- DEFAULT CURRENT_TIMESTAMP
        DocumentVersion          float32   `bson:"documentVersion" json:"documentVersion"`                   // Document version to keep track of the changes -- DEFAULT 1.0
}

// metaData of HTTP API response
// swagger:model metaData
type metaData struct {
        // code
        Code int `json:"code"`
        // msg
        Msg string `json:"msg"`
}

// dealerContactsRespObj
// swagger:response dealerContactsRespObj
type dealerContactsRespObj struct {
        // in: body
        Meta metaData `json:"meta"`
        // in: body
        Data []DealerContact `json:"data,omitempty"`
}

// dealerGoalRespObj
// swagger:response dealerGoalRespObj
type dealerGoalRespObj struct {
        // in: body
        Meta metaData `json:"meta"`
        // in: body
        Data DealerGoal `json:"data,omitempty"`
}

// dealerGoalsRespObj
// swagger:response dealerGoalsRespObj
type dealerGoalsRespObj struct {
        // in: body
        Meta metaData `json:"meta"`
        // in: body
        Data []DealerGoal `json:"data,omitempty"`
}

// fixedOperationRespObj
// swagger:response fixedOperationRespObj
type fixedOperationRespObj struct {
        // in: body
        Meta metaData `json:"meta"`
        // in: body
        Data FixedOperation `json:"data,omitempty"`
}

// fixedOperationsRespObj
// swagger:response fixedOperationsRespObj
type fixedOperationsRespObj struct {
        // in: body
        Meta metaData `json:"meta"`
        // in: body
        Data []FixedOperation `json:"data,omitempty"`
}

// dealerContactRespObj
// swagger:response dealerContactRespObj
type dealerContactRespObj struct {
        // in: body
        Meta metaData `json:"meta"`
        // in: body
        Data DealerContact `json:"data,omitempty"`
}

// dealerRespObj
// swagger:response dealerRespObj
type dealerRespObj struct {
        // in: body
        Meta metaData `json:"meta"`
        // in: body
        Data Dealer `json:"data,omitempty"`
}

// dealerGroupsRespObj
// swagger:response dealerGroupsRespObj
type dealerGroupsRespObj struct {
        // in: body
        Meta metaData `json:"meta"`
        // in: body
        Data []DealerGroup `json:"data,omitempty"`
}

*/
//Missing collections in mongo -- end
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package dealerService
// title: dealer micro service
//
// dealerService implements dealer micro service.
//
// The purpose of this application is to provides api's to perform CURD operations on dealer object.
// Currently only get endpoints are available.
// dealerService is divided into 4 file.
//  1. dealerRoutes.go  -&gt; contain routes.
//  2. dealerHandler.go -&gt; containing handler functions.
//  3. dealerModel.go   -&gt; containing models.
//  4. dealerUtils.go   -&gt; containing util functions.
//
// Terms Of Service:
//
//     Schemes: https
//     BasePath: /tdealer
//     Version: 1.0.0
//     Contact: Qasim Hasnain&lt;mqhasnain@tekion.com&gt;
//
//     Consumes:
//     - application/json
//
//     Produces:
//     - application/json
//
// swagger:meta
package dealerService

import (
        "bitbucket.org/tekion/tacl/acl"
        "bitbucket.org/tekion/tbaas/log"
        "bitbucket.org/tekion/tbaas/tapi"
)

//TODO : Need new admin scope

// Start add routes and start the service at specified port
func Start() <span class="cov0" title="0">{
        tapi.AddRoutes(
                "Read dealer",
                "GET",
                "/dealer",
                readDealer,
                acl.ACLStruct{
                        PermittedRoles: []string{"ServiceAdvisor", "Technician", "Dispatcher"},
                },
        )
        tapi.AddRoutes(
                "Reads dealer fixedoperation",
                "GET",
                "/fixedoperation/{foid}",
                readFixedOperation,
                acl.ACLStruct{
                        PermittedRoles: []string{"ServiceAdvisor", "Technician", "Dispatcher"},
                },
        )
        tapi.AddRoutes(
                "Reads dealer fixedoperations",
                "GET",
                "/fixedoperations",
                readFixedOperations,
                acl.ACLStruct{
                        PermittedRoles: []string{"ServiceAdvisor", "Technician", "Dispatcher"},
                },
        )
        tapi.AddRoutes(
                "Reads dealer contact",
                "GET",
                "/contact/{cid}",
                readDealerContact,
                acl.ACLStruct{
                        PermittedRoles: []string{"ServiceAdvisor", "Technician", "Dispatcher"},
                },
        )
        tapi.AddRoutes(
                "Reads dealer contacts",
                "GET",
                "/contacts",
                readDealerContacts,
                acl.ACLStruct{
                        PermittedRoles: []string{"ServiceAdvisor", "Technician", "Dispatcher"},
                },
        )
        tapi.AddRoutes(
                "Reads dealer goal",
                "GET",
                "/goal/{gid}",
                readDealerGoal,
                acl.ACLStruct{
                        PermittedRoles: []string{"ServiceAdvisor", "Technician", "Dispatcher"},
                },
        )
        tapi.AddRoutes(
                "Reads dealer goals",
                "GET",
                "/goals",
                readDealerGoals,
                acl.ACLStruct{
                        PermittedRoles: []string{"ServiceAdvisor", "Technician", "Dispatcher"},
                },
        )
        tapi.AddRoutes(
                "Reads groups",
                "GET",
                "/groups",
                readDealerGroups,
                acl.ACLStruct{
                        PermittedRoles: []string{"ServiceAdvisor", "Technician", "Dispatcher"},
                },
        )
        //log service start info
        log.GenericInfo("", "", "", "Started Tekion tdealer on port:8079")
        tapi.Start("8079", "/tdealer")
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package dealerService

import (
        "net/http"
        "strings"

        "gopkg.in/mgo.v2/bson"

        "bitbucket.org/tekion/tbaas/apiContext"
        "bitbucket.org/tekion/tbaas/log"
        mMgr "bitbucket.org/tekion/tbaas/mongoManager"
)

// TODO : should be moved to some common library
// fetchFieldsFromRequest reads the query string and fetches "fields" parameter.
// It return slice of strings or nil if "fields" parameter was not found in query string.
func fetchFieldsFromRequest(r *http.Request) []string <span class="cov8" title="1">{
        q := r.URL.Query()
        requestedFields := q.Get("fields")
        if len(requestedFields) != 0 </span><span class="cov8" title="1">{
                return strings.Split(requestedFields, ",")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// TODO : should be moved to some common library
// selectedFields forms a map, key = selected field and value = 1
func selectedFields(fields []string) bson.M <span class="cov8" title="1">{
        selected := make(bson.M, len(fields))
        for _, s := range fields </span><span class="cov8" title="1">{
                selected[s] = 1
        }</span>
        <span class="cov8" title="1">return selected</span>
}

// TODO : should be moved to some common library
// fetchOne reads only one object from mongo and populates it in data parameter passed to the function.
// Returns 1st object if multiple objects are selected by selector parameter.
func fetchOne(ctx apiContext.APIContext, collectionName string, selector bson.M, fields []string, data interface{}) error <span class="cov8" title="1">{
        tenantName := ctx.Tenant
        mongo, err := mMgr.GetS(tenantName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Collection
        <span class="cov8" title="1">c := mongo.DB(tenantName).C(collectionName)

        err = c.Find(selector).Select(selectedFields(fields)).One(data)
        if err != nil </span><span class="cov8" title="1">{
                log.GenericError(ctx.Tenant, ctx.DealerID, ctx.UserName, err)
                return err
        }</span>
        <span class="cov8" title="1">return err</span>
}

// fetchDealerGroups reads list of dealer groups from mongo based on the selector passed.
// Populates it in data parameter passed to the function.
func fetchDealerGroups(ctx apiContext.APIContext, selector bson.M, fields []string, data *[]dealerGroup) error <span class="cov8" title="1">{
        mongo, err := mMgr.GetS(ctx.Tenant)
        if err != nil </span><span class="cov8" title="1">{
                log.GenericError(ctx.Tenant, ctx.DealerID, ctx.UserName, err)
                return err
        }</span>
        // Collection
        <span class="cov8" title="1">c := mongo.DB(ctx.Tenant).C(getDealerGroupCollectionName())

        err = c.Find(selector).Select(selectedFields(fields)).All(data)
        if err != nil </span><span class="cov0" title="0">{
                log.GenericError(ctx.Tenant, ctx.DealerID, ctx.UserName, err)
                return err
        }</span>
        <span class="cov8" title="1">return err</span>
}

// fetchDealerContacts reads list of dealer contacts from mongo based on the selector passed.
// Populates it in data parameter passed to the function.
func fetchDealerContacts(ctx apiContext.APIContext, selector bson.M, fields []string, data *[]dealerContact) error <span class="cov8" title="1">{
        mongo, err := mMgr.GetS(ctx.Tenant)
        if err != nil </span><span class="cov8" title="1">{
                log.GenericError(ctx.Tenant, ctx.DealerID, ctx.UserName, err)
                return err
        }</span>
        // Collection
        <span class="cov8" title="1">c := mongo.DB(ctx.Tenant).C(getDealerContactCollectionName())

        err = c.Find(selector).Select(selectedFields(fields)).All(data)
        if err != nil </span><span class="cov0" title="0">{
                log.GenericError(ctx.Tenant, ctx.DealerID, ctx.UserName, err)
                return err
        }</span>
        <span class="cov8" title="1">return err</span>
}

// fetchFixedOperations reads list of dealer fixed operations from mongo based on the selector passed.
// Populates it in data parameter passed to the function.
func fetchFixedOperations(ctx apiContext.APIContext, selector bson.M, fields []string, data *[]FixedOperation) error <span class="cov8" title="1">{
        mongo, err := mMgr.GetS(ctx.Tenant)
        if err != nil </span><span class="cov8" title="1">{
                log.GenericError(ctx.Tenant, ctx.DealerID, ctx.UserName, err)
                return err
        }</span>
        // Collection
        <span class="cov8" title="1">c := mongo.DB(ctx.Tenant).C(getFixedOperationCollectionName())

        err = c.Find(selector).Select(selectedFields(fields)).All(data)
        if err != nil </span><span class="cov0" title="0">{
                log.GenericError(ctx.Tenant, ctx.DealerID, ctx.UserName, err)
                return err
        }</span>
        <span class="cov8" title="1">return err</span>
}

// fetchDealerGoals reads list of dealer goals from mongo based on the selector passed.
// Populates it in data parameter passed to the function.
func fetchDealerGoals(ctx apiContext.APIContext, selector bson.M, fields []string, data *[]dealerGoal) error <span class="cov8" title="1">{
        mongo, err := mMgr.GetS(ctx.Tenant)
        if err != nil </span><span class="cov8" title="1">{
                log.GenericError(ctx.Tenant, ctx.DealerID, ctx.UserName, err)
                return err
        }</span>
        // Collection
        <span class="cov8" title="1">c := mongo.DB(ctx.Tenant).C(getDealerGoalCollectionName())

        err = c.Find(selector).Select(selectedFields(fields)).All(data)
        if err != nil </span><span class="cov0" title="0">{
                log.GenericError(ctx.Tenant, ctx.DealerID, ctx.UserName, err)
                return err
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
